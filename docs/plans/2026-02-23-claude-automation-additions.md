# Claude Automation Additions Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add 5 new Claude Code automations (2 hooks, 2 skills, 1 subagent) and wire them into settings.json.

**Architecture:** Each automation is a standalone file following existing patterns. Hooks use the established stdin-JSON → python3-parse → case-match pattern. Skills use YAML frontmatter + Markdown. The subagent follows the security-reviewer.md template.

**Tech Stack:** Bash (hooks), Markdown (skills/agents), JSON (settings.json), PostgreSQL MCP (db-debug skill)

---

### Task 1: Create auto-generated file guard hook

**Files:**
- Create: `.claude/hooks/auto-generated-file-guard.sh`

**Step 1: Write the hook script**

```bash
#!/usr/bin/env bash
# PreToolUse hook: block Write/Edit on auto-generated files.
# These files are managed by build tools and should not be manually edited.
#
# Exit codes:
#   0 = allow (not an auto-generated file)
#   2 = block (auto-generated file detected, message shown to user)
#
# Fail-open: if JSON parsing fails, exit 0 so normal operations are not disrupted.

set -euo pipefail

# Parse PreToolUse JSON from stdin
read -r INPUT 2>/dev/null || exit 0

FILE_PATH=$(python3 -c "
import json, sys
data = json.loads(sys.argv[1])
print(data.get('tool_input', {}).get('file_path', ''))
" "$INPUT" 2>/dev/null) || exit 0

# Exit if no file path found
[[ -z "$FILE_PATH" ]] && exit 0

# Normalize to basename for pattern matching
BASENAME=$(basename "$FILE_PATH")

# --- Block auto-generated basename patterns ---
case "$BASENAME" in
  package-lock.json)
    echo "BLOCKED: '$BASENAME' is auto-generated by npm install. Run 'npm install' to update it." >&2
    exit 2
    ;;
  gradlew | gradlew.bat)
    echo "BLOCKED: '$BASENAME' is auto-generated by Gradle Wrapper. Use 'gradle wrapper' to update it." >&2
    exit 2
    ;;
  tsconfig.tsbuildinfo)
    echo "BLOCKED: '$BASENAME' is a TypeScript build cache. It is auto-generated by tsc." >&2
    exit 2
    ;;
esac

# --- Block auto-generated path patterns ---
case "$FILE_PATH" in
  */gradle/wrapper/*)
    echo "BLOCKED: Gradle Wrapper files are auto-generated. Use 'gradle wrapper' to update." >&2
    exit 2
    ;;
  */.next/*)
    echo "BLOCKED: '.next/' is the Next.js build output directory. Run 'npm run build' instead." >&2
    exit 2
    ;;
  */node_modules/*)
    echo "BLOCKED: 'node_modules/' contains installed packages. Use 'npm install' to manage." >&2
    exit 2
    ;;
esac

exit 0
```

**Step 2: Make the script executable**

Run: `chmod +x .claude/hooks/auto-generated-file-guard.sh`

**Step 3: Test the hook manually**

Run the following to verify blocking works:
```bash
echo '{"tool_name":"Write","tool_input":{"file_path":"/home/devman/repos/miometory/frontend/package-lock.json"}}' | .claude/hooks/auto-generated-file-guard.sh
echo "Exit code: $?"
```
Expected: stderr message containing "BLOCKED" and exit code 2.

Then verify allow works:
```bash
echo '{"tool_name":"Write","tool_input":{"file_path":"/home/devman/repos/miometory/frontend/app/page.tsx"}}' | .claude/hooks/auto-generated-file-guard.sh
echo "Exit code: $?"
```
Expected: no output, exit code 0.

**Step 4: Commit**

```bash
git add .claude/hooks/auto-generated-file-guard.sh
git commit -m "feat: add auto-generated file guard hook"
```

---

### Task 2: Create TypeScript type check hook

**Files:**
- Create: `.claude/hooks/typecheck-on-edit.sh`

**Step 1: Write the hook script**

```bash
#!/usr/bin/env bash
# PostToolUse hook: run TypeScript type check after editing frontend files.
# Informational only — always exits 0, never blocks.
#
# Routes: frontend .ts/.tsx files → npx tsc --noEmit
# Leverages incremental compilation (tsconfig.json has incremental: true).

set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "$0")/../.." && pwd)"

# Read PostToolUse JSON from stdin and extract file_path
FILE_PATH=$(python3 -c "
import json, sys
data = json.load(sys.stdin)
tool_input = data.get('tool_input', {})
print(tool_input.get('file_path', ''))
" 2>/dev/null) || exit 0

# Exit if no file path found
[[ -z "$FILE_PATH" ]] && exit 0

# Exit if file doesn't exist
[[ ! -f "$FILE_PATH" ]] && exit 0

# Only check frontend TypeScript files
case "$FILE_PATH" in
  */frontend/*.ts | */frontend/*.tsx)
    OUTPUT=$(cd "$PROJECT_ROOT/frontend" && timeout 30 npx tsc --noEmit --pretty 2>&1) || {
      # Type errors found — output to stderr as info
      echo "$OUTPUT" >&2
    }
    ;;
esac

exit 0
```

**Step 2: Make the script executable**

Run: `chmod +x .claude/hooks/typecheck-on-edit.sh`

**Step 3: Test the hook manually**

Run with a valid frontend file path to verify it runs tsc:
```bash
echo '{"tool_name":"Edit","tool_input":{"file_path":"/home/devman/repos/miometory/frontend/app/page.tsx"}}' | .claude/hooks/typecheck-on-edit.sh
echo "Exit code: $?"
```
Expected: exit code 0 (regardless of type errors). If type errors exist, they appear on stderr.

Run with a non-frontend file to verify it skips:
```bash
echo '{"tool_name":"Edit","tool_input":{"file_path":"/home/devman/repos/miometory/backend/build.gradle.kts"}}' | .claude/hooks/typecheck-on-edit.sh
echo "Exit code: $?"
```
Expected: exit code 0, no output.

**Step 4: Commit**

```bash
git add .claude/hooks/typecheck-on-edit.sh
git commit -m "feat: add TypeScript type check hook (info-only)"
```

---

### Task 3: Wire hooks into settings.json

**Files:**
- Modify: `.claude/settings.json`

**Step 1: Add auto-generated-file-guard to PreToolUse Write|Edit matcher**

In `.claude/settings.json`, add to the existing `PreToolUse` → `Write|Edit` matcher's hooks array (after the sensitive-file-guard entry):

```json
{
  "type": "command",
  "command": ".claude/hooks/auto-generated-file-guard.sh",
  "timeout": 5
}
```

**Step 2: Add typecheck-on-edit to PostToolUse Write|Edit matcher**

In `.claude/settings.json`, add to the existing `PostToolUse` → `Write|Edit` matcher's hooks array (after the auto-test-on-edit entry):

```json
{
  "type": "command",
  "command": ".claude/hooks/typecheck-on-edit.sh",
  "timeout": 30
}
```

**Step 3: Verify settings.json is valid JSON**

Run: `python3 -c "import json; json.load(open('.claude/settings.json'))"`
Expected: no output (valid JSON).

**Step 4: Commit**

```bash
git add .claude/settings.json
git commit -m "feat: wire new hooks into settings.json"
```

---

### Task 4: Create db-debug skill

**Files:**
- Create: `.claude/skills/db-debug/SKILL.md`

**Step 1: Create the skill directory**

Run: `mkdir -p .claude/skills/db-debug`

**Step 2: Write the skill file**

The skill uses PostgreSQL MCP server (`postgres-mcp`) for all database queries. The event store table is named `event_store` (not `domain_events`). Key columns: `id`, `aggregate_type`, `aggregate_id`, `event_type`, `payload` (JSONB), `version`, `created_at`. There is also a `snapshot_store` table for aggregate snapshots.

```markdown
---
name: db-debug
description: Debug Event Sourcing state by querying event_store and projection tables via PostgreSQL MCP
disable-model-invocation: true
---

# Event Sourcing Debugger

Debug aggregate state, event history, and projection consistency using the PostgreSQL MCP server.

## Usage

`/db-debug <aggregate-id>` — Show events and state for a specific aggregate
`/db-debug recent [N]` — Show the N most recent events (default: 20)
`/db-debug types` — List all aggregate types and event counts

## Prerequisites

The PostgreSQL MCP server (`postgres-mcp`) must be configured and the dev database must be running.

## Workflow

### 1. Parse Arguments

- If argument is a UUID: treat as aggregate ID
- If argument is `recent` with optional count: show recent events
- If argument is `types`: show aggregate type summary
- If no argument: show usage help

### 2. Query Event Store

Use the PostgreSQL MCP `query` tool for all database operations.

**For a specific aggregate ID:**

```sql
-- Event history (time-ordered)
SELECT event_type, version, payload, created_at
FROM event_store
WHERE aggregate_id = '<uuid>'
ORDER BY version ASC;

-- Aggregate type
SELECT DISTINCT aggregate_type
FROM event_store
WHERE aggregate_id = '<uuid>'
LIMIT 1;

-- Latest snapshot (if exists)
SELECT version, state, created_at
FROM snapshot_store
WHERE aggregate_id = '<uuid>';
```

**For recent events:**

```sql
SELECT aggregate_type, aggregate_id, event_type, version, created_at
FROM event_store
ORDER BY created_at DESC
LIMIT <N>;
```

**For type summary:**

```sql
SELECT aggregate_type, COUNT(*) as event_count,
       COUNT(DISTINCT aggregate_id) as aggregate_count,
       MAX(created_at) as latest_event
FROM event_store
GROUP BY aggregate_type
ORDER BY event_count DESC;
```

### 3. Check Projection Consistency

Based on the aggregate_type, query the corresponding projection table:

| Aggregate Type | Projection Table | Key Fields |
|---------------|-----------------|------------|
| WorkLogEntry | work_log_entry_* | member_id, entry_date, hours |
| Absence | absence_* | member_id, start_date, end_date |
| Tenant | tenant | code, name, status, version |
| Organization | organization | code, name, status, version |
| FiscalYearPattern | fiscal_year_pattern | start_month, start_day, version |
| MonthlyPeriodPattern | monthly_period_pattern | start_day, version |
| MonthlyApproval | daily_entry_approval | status |

Compare the `version` in the projection table with the max `version` in event_store for the aggregate. Report any discrepancy.

### 4. Output Format

```
## Event History: <aggregate_id>
Aggregate Type: <type>
Total Events: <count>
Current Version: <max_version>
Snapshot Version: <snapshot_version or "none">

| # | Event Type | Version | Timestamp |
|---|-----------|---------|-----------|
| 1 | Created   | 1       | 2024-...  |
| 2 | Updated   | 2       | 2024-...  |

### Projection Check
- Projection version: <version>
- Event store version: <version>
- Status: ✅ Consistent / ⚠️ Version mismatch (projection behind by N events)

### Latest Event Payload
<formatted JSON of the most recent event payload>
```
```

**Step 3: Commit**

```bash
git add .claude/skills/db-debug/SKILL.md
git commit -m "feat: add db-debug skill for Event Sourcing debugging"
```

---

### Task 5: Create deploy-check skill

**Files:**
- Create: `.claude/skills/deploy-check/SKILL.md`

**Step 1: Create the skill directory**

Run: `mkdir -p .claude/skills/deploy-check`

**Step 2: Write the skill file**

Key project facts for the checks:
- Backend build: `cd backend && ./gradlew build`
- Frontend build: `cd frontend && npm run build`
- Migrations: `backend/src/main/resources/db/migration/V*.sql` (V1 through V19 currently)
- Seed data: `backend/src/main/resources/db/migration/R__dev_seed_data.sql`
- Docker prod config: `infra/docker/docker-compose.prod.yml`

```markdown
---
name: deploy-check
description: Run pre-deployment checklist to verify migration continuity, builds, tests, and configuration
disable-model-invocation: true
---

# Pre-Deployment Checklist

Automatically verify that the project is ready for production deployment.

## Usage

`/deploy-check` — Run all checks
`/deploy-check --quick` — Skip build and test steps (migration + config only)

## Checks

Run each check in order. Report Pass/Fail for each and stop on critical failures.

### 1. Git Status Check

Verify no uncommitted changes exist:
```bash
git status --porcelain
```
- **Pass**: No output (clean working tree)
- **Fail**: List uncommitted files and warn

### 2. Flyway Migration Version Continuity

Scan migration files for version gaps or duplicates:
```bash
ls backend/src/main/resources/db/migration/V*.sql | sed 's/.*V\([0-9]*\)__.*/\1/' | sort -n
```
- **Pass**: Version numbers are sequential with no gaps or duplicates
- **Fail**: Report which versions are missing or duplicated

Also check naming convention:
- Files must match pattern `V{N}__{snake_case_description}.sql`
- No spaces, uppercase, or special characters in description

### 3. Seed Data Coverage

Check that `R__dev_seed_data.sql` includes INSERT statements for all tables referenced in migrations:
```bash
# Extract table names from CREATE TABLE statements
grep -h "CREATE TABLE" backend/src/main/resources/db/migration/V*.sql | sed 's/.*CREATE TABLE.*IF NOT EXISTS\s\+//' | sed 's/.*CREATE TABLE\s\+//' | sed 's/\s*(.*//' | sort -u

# Extract table names from seed data INSERT statements
grep -h "INSERT INTO" backend/src/main/resources/db/migration/R__dev_seed_data.sql | sed 's/.*INSERT INTO\s\+//' | sed 's/\s*(.*//' | sort -u
```
- **Pass**: All tables have seed data entries (excluding system tables like `event_store`, `snapshot_store`, `audit_log`)
- **Warn**: Tables without seed data (list them)

### 4. Backend Build

```bash
cd backend && ./gradlew build --no-daemon 2>&1
```
- **Pass**: BUILD SUCCESSFUL
- **Fail**: Show error output

### 5. Frontend Build

```bash
cd frontend && npm run build 2>&1
```
- **Pass**: Exit code 0
- **Fail**: Show error output

### 6. Docker Compose Config Validation

```bash
cd infra/docker && docker compose -f docker-compose.prod.yml config --quiet 2>&1
```
- **Pass**: No errors
- **Fail**: Show config errors

### 7. Summary Report

```
## Deploy Readiness Report

| Check | Status |
|-------|--------|
| Git Status | ✅ Clean / ⚠️ Uncommitted changes |
| Migration Continuity | ✅ Sequential / ❌ Gaps found |
| Seed Data Coverage | ✅ Complete / ⚠️ Missing tables |
| Backend Build | ✅ Pass / ❌ Fail |
| Frontend Build | ✅ Pass / ❌ Fail |
| Docker Config | ✅ Valid / ❌ Invalid |

### Overall: ✅ Ready / ⚠️ Warnings / ❌ Not Ready
```
```

**Step 3: Commit**

```bash
git add .claude/skills/deploy-check/SKILL.md
git commit -m "feat: add deploy-check skill for pre-deployment validation"
```

---

### Task 6: Create migration-reviewer subagent

**Files:**
- Create: `.claude/agents/migration-reviewer.md`

**Step 1: Write the agent file**

Model the frontmatter after `security-reviewer.md` and `build-integrity-verifier.md`. Use haiku model for cost efficiency. The agent reviews Flyway SQL migrations for safety and convention compliance.

Key context to encode:
- Event store table: `event_store` (not domain_events)
- Project conventions: tenant_id FK, UUID PK, timestamps, ON CONFLICT in seed data
- Migrations directory: `backend/src/main/resources/db/migration/`
- Current migration range: V1–V19

```markdown
---
name: migration-reviewer
description: "Review Flyway migration files for safety risks including irreversible changes, data loss, FK constraint issues, lock contention, and convention compliance. Use when migration files are added or modified.\n\nExamples:\n\n- Example 1:\n  user: \"新しいマイグレーションファイルを作成しました\"\n  assistant: \"マイグレーションの安全性をレビューするためmigration-reviewerエージェントを起動します。\"\n  <Task agent=\"migration-reviewer\">新規マイグレーションファイルの安全性をレビューしてください。変更されたファイル: backend/src/main/resources/db/migration/V20__xxx.sql</Task>\n\n- Example 2:\n  user: \"テーブルのカラムを変更するマイグレーションを追加して\"\n  assistant: \"カラム変更のマイグレーションを作成しました。安全性レビューを実行します。\"\n  <Task agent=\"migration-reviewer\">ALTER TABLE文を含むマイグレーションの安全性を検証してください。変更されたファイル: backend/src/main/resources/db/migration/V20__alter_xxx.sql</Task>"
tools: Read, Glob, Grep, Bash
model: haiku
color: orange
---

あなたはFlywayデータベースマイグレーションの安全性レビューの専門家です。PostgreSQLとEvent Sourcingアーキテクチャに精通し、マイグレーションに潜むリスクを検出してきた経験を持つエキスパートです。

## プロジェクトコンテキスト

- **DB**: PostgreSQL 17 with JSONB
- **マイグレーション**: Flyway (V1〜V19が存在)
- **パス**: `backend/src/main/resources/db/migration/`
- **Event Store**: `event_store`テーブル (aggregate_type, aggregate_id, event_type, payload JSONB, version, created_at)
- **Snapshot Store**: `snapshot_store`テーブル (aggregate_id, aggregate_type, version, state JSONB)
- **マルチテナント**: 全ドメインテーブルに`tenant_id` FK必須

## レビューチェックリスト

### 1. 不可逆変更の検出 (CRITICAL)
- `DROP TABLE` — テーブル全体の削除
- `DROP COLUMN` — カラムの削除（データ消失）
- `ALTER COLUMN ... TYPE` — データ型変更（暗黙的なデータ変換による損失リスク）
- `TRUNCATE` — テーブル全行削除
- これらがある場合、ロールバック計画の有無を確認する

### 2. データ損失リスク (HIGH)
- `DELETE FROM` — 条件なしの一括削除
- `NOT NULL`制約の追加（既存のNULL行が存在する場合に失敗）
- カラム削除前のデータ移行有無
- `DEFAULT`値なしの`NOT NULL`カラム追加

### 3. FK制約の整合性 (HIGH)
- 新テーブルの`*_id`カラムにFK制約(`REFERENCES`)があるか
- 参照先テーブルが既に存在するか（マイグレーション順序）
- `ON DELETE`ポリシーの妥当性（CASCADE, SET NULL, RESTRICT）
- 循環参照のリスク

### 4. ロック競合リスク (MEDIUM)
- 大テーブルへの`ALTER TABLE ADD COLUMN ... NOT NULL`（テーブルロック）
- `CREATE INDEX`（`CONCURRENTLY`オプションの推奨）
- `ALTER TABLE ... ADD CONSTRAINT`（既存行のスキャンによるロック）
- 推奨: `CREATE INDEX CONCURRENTLY`を使用すること

### 5. Event Sourcingスキーマ保護 (CRITICAL)
- `event_store`テーブルへの変更は原則禁止（イミュータブルなイベントログ）
- `snapshot_store`への変更は慎重にレビュー
- プロジェクションテーブルの変更がイベントスキーマと矛盾しないか

### 6. プロジェクト規約の準拠 (MEDIUM)
- `tenant_id UUID NOT NULL REFERENCES tenant(id)` — マルチテナントテーブルに必須
- `UUID`主キー
- `created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP`
- `updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP`（更新が予想されるテーブル）
- インデックス: FK列と頻繁なクエリパターン
- `COMMENT ON TABLE/COLUMN` — テーブルとカラムの説明
- バージョン番号の連続性（V1, V2, ...）

### 7. べき等性 (MEDIUM)
- `CREATE TABLE IF NOT EXISTS` の使用
- `CREATE INDEX IF NOT EXISTS` の使用
- シードデータの`ON CONFLICT ... DO UPDATE SET` パターン

## 出力形式

security-reviewer.mdと同じ形式:

```
### [SEVERITY] Finding Title

- **Severity**: CRITICAL / HIGH / MEDIUM / LOW / INFO
- **Location**: `migration-file:line` or SQL statement reference
- **Description**: What the risk is
- **Impact**: What could go wrong in production
- **Fix**: Specific fix recommendation
```

Severityの高い順に並べる（CRITICAL → HIGH → MEDIUM → LOW → INFO）。

問題がない場合は以下を出力:
```
### ✅ マイグレーションレビュー完了

レビュー対象ファイルに安全性の問題は検出されませんでした。
プロジェクト規約にも準拠しています。
```

## レビュー手順

1. 対象のマイグレーションファイルを読む
2. 上記チェックリストの各項目を順番に検証する
3. 既存のマイグレーション（V1〜V19）との整合性を確認する（必要な場合のみ）
4. 結果をフォーマットして報告する
```

**Step 2: Commit**

```bash
git add .claude/agents/migration-reviewer.md
git commit -m "feat: add migration-reviewer subagent for Flyway safety review"
```

---

### Task 7: Update design doc with corrections

**Files:**
- Modify: `docs/plans/2026-02-23-claude-automation-additions-design.md`

**Step 1: Fix event table name**

The design doc references `domain_events` but the actual table is `event_store`. Update all references.

**Step 2: Commit**

```bash
git add docs/plans/2026-02-23-claude-automation-additions-design.md
git commit -m "fix: correct event table name from domain_events to event_store in design doc"
```

---

### Task 8: End-to-end verification

**Step 1: Verify all new files exist and are executable (hooks)**

```bash
ls -la .claude/hooks/auto-generated-file-guard.sh .claude/hooks/typecheck-on-edit.sh
ls -la .claude/skills/db-debug/SKILL.md .claude/skills/deploy-check/SKILL.md
ls -la .claude/agents/migration-reviewer.md
```

**Step 2: Validate settings.json structure**

```bash
python3 -c "import json; d=json.load(open('.claude/settings.json')); print('PreToolUse hooks:', len(d['hooks']['PreToolUse'])); print('PostToolUse hooks:', len(d['hooks']['PostToolUse']))"
```
Expected: PreToolUse hooks: 2, PostToolUse hooks: 1 (each matcher can have multiple hook commands within).

**Step 3: Run both hooks with test input to verify no crashes**

```bash
# Auto-generated guard - should block
echo '{"tool_name":"Write","tool_input":{"file_path":"frontend/package-lock.json"}}' | .claude/hooks/auto-generated-file-guard.sh 2>&1; echo "exit: $?"

# Auto-generated guard - should allow
echo '{"tool_name":"Write","tool_input":{"file_path":"frontend/app/page.tsx"}}' | .claude/hooks/auto-generated-file-guard.sh 2>&1; echo "exit: $?"

# TypeCheck - should exit 0 for non-frontend file
echo '{"tool_name":"Edit","tool_input":{"file_path":"backend/build.gradle.kts"}}' | .claude/hooks/typecheck-on-edit.sh 2>&1; echo "exit: $?"
```

**Step 4: Verify settings.json hasn't broken existing hooks**

```bash
# Existing sensitive-file-guard should still work
echo '{"tool_name":"Write","tool_input":{"file_path":".env"}}' | .claude/hooks/sensitive-file-guard.sh 2>&1; echo "exit: $?"
```
Expected: BLOCKED message, exit 2.
